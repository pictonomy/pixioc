/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package net.pixlib.ioc.parser.factory {	import net.pixlib.log.PXStringifier;
	import net.pixlib.collections.PXArrayIterator;	import net.pixlib.collections.PXIterator;	import net.pixlib.exceptions.PXUnimplementedMethodException;	import net.pixlib.ioc.parser.PXParserCollection;	/**	 * Abstract implementation for IoC parsers collection.	 * 	 * @author Romain Ecarnot	 */	public class PXAbstractParserCollection implements PXParserCollection	{		//--------------------------------------------------------------------		// Private properties		//--------------------------------------------------------------------		private var _oAsProcessor : PXASPreProcessorParser;				//--------------------------------------------------------------------		// Protected properties		//--------------------------------------------------------------------				/** Collection of parser commands. */		protected var oCollection : Vector.<PXParserCommand>;				//--------------------------------------------------------------------		// Public API		//--------------------------------------------------------------------				/**		 * @inheritDoc		 */		public function addParserBefore( searchParser : PXParserCommand, parser : PXParserCommand ) : Boolean		{			var index : int = oCollection.indexOf( searchParser ) ;			if( parser == null && index != -1) return false;						return addCommandAt( index, parser ) ;		}				/**		 * @inheritDoc		 */		public function addParserAfter( searchParser : PXParserCommand, parser : PXParserCommand ) : Boolean		{			var index : int = oCollection.indexOf( searchParser ) ;			if( parser == null && index != -1) return false;						return addCommandAt( index + 1, parser ) ;		}				/**		 * @inheritDoc		 */		public function addParserStart( parser : PXParserCommand ) : Boolean		{			return addCommandAt( 0, parser ) ;		}				/**		 * @inheritDoc		 */		public function addParserEnd( parser : PXParserCommand ) : Boolean		{			return addCommandAt( oCollection.length, parser ) ;		}				/**		 * @inheritDoc		 */		public function removeParser( parser : PXParserCommand ) : Boolean		{			var index : int = oCollection.indexOf( parser ); 			if ( index == -1 ) return false;			while ( ( index = oCollection.indexOf( parser ) ) != -1 ) oCollection.splice( index, 1 );			return true;		}				/**		 * Returns dedicated hard coded preprocessors parser.		 * 		 * @return Dedicated hard coded preprocessors parser.		 */		public function getASPreProcessor( ) : PXASPreProcessorParser		{			return _oAsProcessor;		}				/**		 * Returns an Iterator throw all collections parser command.		 * 		 * @return An Iterator throw all collections parser command		 */		public function iterator( ) : PXIterator		{			var arr : Array = new Array();			var length : uint = oCollection.length;			for( var i : uint = 0; i < length; i++ ) arr.push( oCollection[i]);			return new PXArrayIterator( arr );		}				/**		 * @inheritDoc		 */		public function release() : void		{			oCollection = null;		}				/**		 * Returns string representation of instance.		 * 		 * @return The string representation of instance.		 */		public function toString() : String		{			return PXStringifier.process( this );		}						//--------------------------------------------------------------------		// Protected methods		//--------------------------------------------------------------------				/**		 * Adds passed-in command at index position in sequencer.		 * 		 * @param	index		Index for insertion (must be valid)		 * @param	command		Command to add		 * 		 * @return	<code>true</code> if <code>command</code> was successfully inserted.		 */		protected function addCommandAt( index : uint, command : PXParserCommand ) : Boolean		{			var length : uint = oCollection.length;						if( command == null || index > length) return false;									oCollection.splice( index, 0, command );			return (length != oCollection.length );		}				/**		 * @private		 */		protected function setParserList( ) : void		{			throw new PXUnimplementedMethodException(".setParserList() must be implemented in concrete class.", this);		}				//--------------------------------------------------------------------		// Private implementation		//--------------------------------------------------------------------				/** @private */		public function PXAbstractParserCollection( )		{			_oAsProcessor = new PXASPreProcessorParser( );						oCollection = new Vector.<PXParserCommand>( );							setParserList( );		}			}}				